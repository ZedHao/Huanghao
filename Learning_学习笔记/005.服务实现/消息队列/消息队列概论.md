[toc]
# 主要考虑指标
## 如何确保消息的精确传输
## 如何确保消息的准确存储
    不丢
## 如何确保消息的正确消费
    不重复消费
# 解决了什么问题
https://zhuanlan.zhihu.com/p/58374824

 链式调用是我们在写程序时候的一般流程，为了完成一个整体功能，会将其拆分成多个函数（或子模块），比如模块A调用模块B，模块B调用模块C，模块C调用模块D。但在大型分布式应用中，系统间的RPC交互繁杂，一个功能背后要调用上百个接口并非不可能，这种架构有如下几个劣势：
-   耦合严重，改A就要周知所有下游
-   每个接口吞吐有限 引起蝴蝶效应
-   有性能问题，木桶理论  RPC接口基本上是同步调用，整体的服务性能遵循“木桶理论”，即链路中最慢的那个接   比如A调用B/C/D都是50ms，但此时B又调用了B1，花费2000ms，那么直接就拖累了整个服务性能。

# 好处
-    系统解耦
-    流量削峰（秒杀常用）
       设置流量缓冲池，流量削峰，可以让后端系统按照自身吞吐能力进行消费，不被冲垮；
-    异步处理
       强弱依赖梳理，将++非关键调用链路的操作异步化++，提升整体系统的吞吐能力（比如下订单扣款发货，物流属于非关键，可以异步）
-    数据分发 一个上游发 多个下游消费

# 流程
   ![image](https://pic4.zhimg.com/80/v2-3630ae95eb61e02c69b4a4a8c4d3ae27_hd.jpg)
  
      A. Client上游如何将消息可靠投递到MQ

        - 1.Client发送消息给MQ
        - 2.MQ将消息持久化后，发送Ack消息给Client，此处有可能因为网络问题导致Ack消息无法发送到Client，那么Client在等待超时后，会重传消息；
        - 3.Client收到Ack消息后，认为消息已经投递成功。
  
      B. MQ如何将消息可靠投递到Client下游

        - 1.MQ将消息push给Client（或Client来pull消息）
        - 2.Client得到消息并做完业务逻辑
        - 3.Client发送Ack消息给MQ，通知MQ删除该消息，此处有可能因为网络问题导致Ack失败，那么Client会重复消息，这里就引出消费幂（命令堵塞）等的问题；
        - 4.MQ将已消费的消息删除
        
# MQ的特点
    1.先进先出 且 数据是只有一条数据在使用中。 这也是MQ在诸多场景被使用的原因。
    2.发布订阅
    3.持久化mq
    4.分布式
    
# mq的两种消息模式     P2P（Point toPoint）和Publish/Sub(Pub/Sub)

![image](https://pic4.zhimg.com/80/v2-508d0ca6ee99ff842612dcc669a76947_hd.jpg)

点对点，一个发，一个消费。涉及到的角色 发布者（Publisher）、消费者（Consumer）、消息队列（Queue）
特点

一个消息只能被一个消费者消费，消费后会从队列里移除
发布者和消费者无关系，发布者发送消息的行为不会随消费者而改变
消费者消费完成消息，需要向队列Ack，消息队列发现消息消费成功即做消息移除

![image](https://pic2.zhimg.com/80/v2-ea04f53e44b191875b868c02c8623861_hd.jpg)

发布订阅模式，一个发布，多方订阅。涉及到的角色有 发布者（Publisher）、主题（Topic）、订阅者（Subscriber）。

特点

每个消息可以有多个消费者
针对某个主题（Topic）的订阅者，必须创建一个订阅者之后，才能消费发布者的消息
为了消费消息，订阅者必须保持运行的状态

# 常见问题和解决方案
## 消息阻塞

1、消息阻塞一般都是流量激增，超过消费者消费能力（扩容）；

2、或者消费者出现逻辑问题，导致不断的重试或长时间等待（紧急航线 跳过）。

## 重复消费
   重复消费一般发生下消费端，比如消费者处理完毕，在准备进行ack的时候出现了问题，应用重启后，消息中间件以为该消息还未处理又推给了消费者，或者消费者拉取的时候重复。

   一般的做法==是消费端做幂==等。
## 消息丢失

消息丢失一般分为生产者发送失败、消息中间件丢失、消费丢失。

生产者丢失：可能以为网络问题或者消息中间处理失败导致，消息遗漏。

消息中间的丢失：一般中间件可以设置丢弃策略，大部分MQ中间件产品可以保证数据不丢失，这种情况基本不用考虑。

消费丢失：有的消息中间件支持自动ack，当消费者消费到消息，消息中间件也不管是否消费成功自动ack。这时候一般选择消费者主动ack比较合适。

有activeMQ、rabbitMQ、rocketMQ、zeroMQ、Kafka
    
#  MQ的消息幂等
举个栗子：购买会员卡，上游支付系统负责给用户扣款，下游系统负责给用户发卡，通过MQ异步通知。不管是上半场的ACK丢失，导致MQ收到重复的消息，还是下半场ACK丢失，导致购卡系统收到重复的购卡通知，都可能出现，上游扣了一次钱，下游发了多张卡。消息总线的幂等性设计至关重要，是本文将要讨论的重点。
## 上游的幂等性设计
    ![image](https://upload-images.jianshu.io/upload_images/6754857-a3979e5fde4136ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/302/format/webp)
    
    MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据，这个内部消息ID的特性是：

（1）全局唯一

（2）MQ生成，具备业务无关性，==对消息发送方和消息接收方==屏蔽

## 下游的幂等性设计
  业务消息体中，必须有一个biz-id，作为去重和幂等的依据，这个业务ID的特性是：

（1）==对于同一个业务场景，全局唯一==

（2）由业务消息发送方生成，业务相关，对MQ透明

（3）由业务消息消费方负责判重，以保证幂等

最常见的业务ID有：支付ID，订单ID，帖子ID等。
## 总结
 MQ为了保证消息必达，消息上下半场均可能发送重复消息，如何保证消息的幂等性呢？
上半场
   MQ-client生成inner-msg-id，保证上半场幂等。这个ID全局唯一，业务无关，由MQ保证。
下半场
  业务发送方带入biz-id，业务接收方去重保证幂等。这个ID对单业务唯一，业务相关，对MQ透明。结论：幂等性，不仅对MQ有要求，对业务上下游也有要求
