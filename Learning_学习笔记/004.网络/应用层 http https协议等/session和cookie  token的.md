# cookie
https://www.cnblogs.com/moyand/p/9047978.html
## cookie 是什么
![image](https://images2017.cnblogs.com/blog/1203274/201712/1203274-20171209110335937-33858862.png)
==Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。==

当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；

## cookie的特性
Cookie具有不可跨域名性
javascript修改伪造cookie，可以设置cookie的httponly属性为true
https://my.oschina.net/xianggao/blog/395675?fromerr=GC9KVenE
# session
https://www.cnblogs.com/woshimrf/p/5317776.html
## 常用的Session实现方式和机制。
四、理解session机制 

session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 

当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 

第一种：就是依赖于Cookie的实现，就是上面我们所说的那种，在这里我就不赘述了。

第二种：URL重写。这种实现方式，是通过在请求的URL后面后缀JESSIONID=xxx这种方式将JESSIONID传递给客户端。

第三种：隐藏的表单域。就是在FORM表单中，设置一个隐藏域，将JESSIONID放置其中，一并发送给服务器端。

## session存在哪里
sessionid是一个会话的key，浏览器第一次访问服务器会在服务器端生成一个session，有一个sessionid和它对应。tomcat生成的sessionid叫做jsessionid。

存储在服务器的内存中，也可以持久化到file，数据库，memcache，redis等。客户端只保存sessionid到cookie中，而不会保存session，session销毁只能通过invalidate或超时，关掉浏览器并不会关闭session。
## session共享
首先我们应该明白，为什么要实现共享，如果你的网站是存放在一个机器上，那么是不存在这个问题的，因为会话数据就在这台机器，但是如果你使用了负载均衡把请求分发到不同的机器呢？这个时候会话id在客户端是没有问题的，但是如果用户的两次请求到了两台不同的机器，而它的session数据可能存在其中一台机器，这个时候就会出现取不到session数据的情况，于是session的共享就成了一个问题。 
　　1.支持通过配置文件修改session的存储介质为sql        
　　2.php支持把会话数据存储到某台memcache服务器，你也可以
　　3.手工把session文件存放的目录改为nfs网络文件系统，从而实现文件的跨机器共享。 
# token
　1、很久很久以前，Web 基本上就是文档的浏览而已， 既然是浏览，作为服务器， 不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议， 就是请求加响应，  尤其是我不用记住是谁刚刚发了HTTP请求，   

2、但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统，  哪些人往自己的购物车中放商品，  也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，所以想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字串，每个人收到的都不一样，  每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了 最初的session

3、这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id ！  如果访问服务器多了， 就得由成千上万，甚至几十万个。

4.后来不存session_id,用cpu计算换存储
比如说， 小F已经登录了系统， 我给他发一个令牌(token)， 里边包含了小F的 user id， 下一次小F 再次通过Http 请求访问我的时候， 把这个token 通过Http header 带过来不就可以了。
不过这和session id没有本质区别啊， 任何人都可以可以伪造，  所以我得想点儿办法， 让别人伪造不了。
那就对数据做一个签名吧， 比如说我用HMAC-SHA256 算法，加上一个只有我才知道的密钥，  对数据做一个签名， 把这个签名和数据一起作为token 就无法伪造token了。
## token的处理过程
1.用户通过用户名和密码发送请求。

2.程序验证。

3.程序返回一个签名的token 给客户端。

4.客户端储存token,并且每次用于每次发送请求。

5.服务端验证token并返回数据。

![image](https://images2018.cnblogs.com/blog/1350514/201805/1350514-20180504123206667-444188772.png)


![image](https://images2018.cnblogs.com/blog/1350514/201805/1350514-20180504123326596-1492094512.png)

![image](https://images2018.cnblogs.com/blog/1350514/201805/1350514-20180504123850641-479661599.png)

# cookie session token
举个简单例子就像人们去超市购物，去存包，第一个去的时候(客户第一次发送请求给服务器),超市会给你一个号码牌(此时服务器产生一个唯一的sessionID，并返回给客户端(通过cookie)),你可以在你自己的柜子里存东西(在服务器属于此客户的内存区域存数据),下次你再去的时候，拿着这个号码牌(请求request中携带cookie),超市就知道哪些东西是你的，然后给你取出来，如果你几天都没去取（session失效了，在服务器端配置）,你再去的时候东西就拿不到了
如果你把这个号码牌丢了(刚才的cookie失效了，比如你重启电脑，刚才存于内存中sessionID也就丢了)，再去拿东西，当然无法定位了，也就拿不到东西了
如果是新打开一个浏览器的情况，那就像是又一个人去超市存东西一样，你的东西跟他的东西是两码事，互不影响,他有他自己的sessionID,你有你自己的


cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。

cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。

session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。

session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。

服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。

