Sleep & Wakeup
# 前期回顾
在多核的系统中，锁可以满足并发控制中对资源互斥的要求，保证共享资源的正确性
在多核系统中，一个CPU会执行多个进程，一个进程也会被调度到多个CPU，锁是Scheduling的基础
# 线程进程切换
    线程调度切换的顺序是
    1.从调度器(获取锁，选择执行进程并切换到进程)
    2. 进程(开始执行，即从swtch返回，随后释放锁)
    3. 进程(时间片到，调用yield重新获取锁，并切换到调度器)
    4. 调度器(此时就相当于返回调度器未切换进程的状态，锁依然是获取着的）


# 进程的休眠和唤醒
## 是什么
就绪线程会被放在线程队列
有时候一些进程必须要等到特定的时间发生，例如设备初始化完成 I/O完成，就会经历休眠和唤醒
## 必要条件
1. 线程休眠前，出让CPU控制，置为SLEEP前 必须加锁 ，不然容易被调度，切换完成置为sleep
2. 同时不能持有其他的锁 【进程P1持有了锁，但是进程P1又不在运行。 -> 死锁】 
3. V6中禁止在调用switch时持有除进程自身锁（注，也就是p->lock）以外的其他锁。
4. 进程P1出让了CPU sleep ，P2持有P1加的锁，P2自旋锁 系统停止运行
## 怎么做
### 死循环 直到我们等待的事情/条件发生 死循环 等到有数据  如果快 就很好
缺点：忙等待，CPU需要一直运行在while循环中，没法做其他事情
### 被动通知 通过sleep&&wake up实现
以信号量协调生产者消费者模型举例，假设他们运行在不同的CPU上

问题：死锁，P拿着s->lock去sleep了，V永远拿不到锁
最终方案：Condition lock
作用：在进程标记为sleeping后释放锁，要解决上述的两个问题：lost wakeups和deadlock


