Sleep & Wakeup
前期回顾
在多核的系统中，锁可以满足并发控制中对资源互斥的要求，保证共享资源的正确性
在多核系统中，一个CPU会执行多个进程，一个进程也会被调度到多个CPU，锁是Scheduling的基础
线程调度切换的顺序是从调度器(获取锁，选择执行进程并切换到进程)->进程(开始执行，即从swtch返回，随后释放锁)->进程(时间片到，调用yield重新获取锁，并切换到调度器)->调度器(此时就相当于返回调度器未切换进程的状态，锁依然是获取着的）

Timer interrupt -> yield -> sched -> yield[swtch] -> scheduler[swtch] -> yield[swtch]
在sched中调用switch，switch完成并返回后，接着在scheduler中调用switch的下一行运行，然后遍历所有进程，找到一个runnable，再switch到该runnable进程，而这次switch完成后，则是从该进程context中ra指向的位置开始运行（不一定是sched中的switch，对于一个被fork产生的进程，他的ra被设置为forkret，所以他被调度之后，是去执行forkret函数）
在vx6中，swtch这种场景下不允许使用除了p->lock之外的lock，容易造成死锁

coordination
放弃CPU直到我们等待的事情/条件发生
    wait for disk read to complete (event is from an interrupt)
    wait for pipe writer to produce data (event is from a thread)
    wait for any child to exit

以信号量协调生产者消费者模型举例，假设他们运行在不同的CPU上

缺点：忙等待，CPU需要一直运行在while循环中，没法做其他事情

缺点：丢失wakeups问题，即在P的212-213行之间，V将s-count改为非0，并且wakeup，这个时候P还没有sleep，所以V的wakeup丢失了，之后P会在sleep等一个已经完成的wakeup

问题：死锁，P拿着s->lock去sleep了，V永远拿不到锁
最终方案：Condition lock
作用：在进程标记为sleeping后释放锁，要解决上述的两个问题：lost wakeups和deadlock

代码
Sleep & wakeup：sleep()函数，wakeup()函数
write->uartputc  & usertrap->devintr->uartintr->uartstart->wakeup
Wait & Exit & kill（zombie：进程的资源还未释放完成，还不能被重新分配）
pipe（pipe和disk在sleep时候对kill的响应不同）

