[toc]
# 树 大全
![image](9EE86B34162E48CD8656BDBB44678C37)
# 各树的原因场景
1. B B+则运用在file system database这类持续存储结构
1. TRIE树：搜索引擎提示
1. 红黑树应用比较广泛：
1. 广泛用在C++的STL中。map和set都是用红黑树实现的。
1. 著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块。
1. epoll在内核中的实现，用红黑树管理事件块
1.  nginx中，用红黑树管理timer等
1. Java的TreeMap实现

# 初级树 
## 二叉树
### 非递归遍历二叉树 
### 递归 BST（==二叉查找树 左子树小右子树大 中序成升序==求k大数）
劣势：全是偏左的树 近似线性

### 哈夫曼huffMan 编码树
![image](https://images2017.cnblogs.com/blog/1322530/201802/1322530-20180203172647750-609170444.png)
#### 哈夫曼树的应用 
最少前缀  学生成绩分布 if else 写法
### 二叉树应用 编译器四则运算 
## 多叉树
多叉树的等价表示 
![image](AEA71E99933B4673B64EDE60A85B5A73)
### 多叉树转二叉树
## K叉树

# 高级树
## 2-3树[B树特例]

## B和B+树

### 概念
![image](https://img-blog.csdn.net/20170920132504569?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YW56aGUxMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。

根节点至少有两个子节点
每个节点有M-1个key，并且以升序排列
位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间
其它节点至少有M/2个子节点
![image](https://img-blog.csdn.net/20170920132523536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YW56aGUxMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

B+树是对B树的一种变形树，它与B树的差异在于：

有k个子结点的结点必然有k个关键码；
非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

### 插入和删除
https://blog.csdn.net/m0_37519490/article/details/80957602


## Trie树(字典树)
![image](https://upload.wikimedia.org/wikipedia/commons/b/be/Trie_example.svg)
## avl和 红黑树比较
红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多

红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构 能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案

搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。

### AVL树 (二叉平衡树)
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为平衡二叉树

![image](https://images0.cnblogs.com/i/566545/201403/311739112822613.png)
 记住旋转方法：必须是 123 高度或者是321高度 递减递增 然后秤砣位移
 如果不是  就采用 ll lr rl rr 变为这样 
http://www.sohu.com/a/270452030_478315
AVL的左旋和右旋
![image](http://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png)
https://blog.csdn.net/collonn/article/details/20128205
![image](https://img-blog.csdn.net/20141201123218032?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29sbG9ubg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

### 红黑树【实现关联数组】
（1）简介

一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，==红黑树确保没有一条路径会比其它路径长出两倍==，因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，==在相同的节点情况下，AVL树的高度低于红黑树==），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树。



==（2）性质==
- 1. 每个节点非红即黑
- 2. 根节点是黑的; 
- 3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的; 
- 4. 如图所示，如果一个节点是红的，那么它的两儿子都是黑的; 
- 5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;
- 6. 每条路径都包含相同的黑节点;

![image](https://img-blog.csdn.net/20180710095739968?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4OTk5ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性
树的左旋
树的左旋(2张)
 质。
为了保持红黑树的性质，我们可以通过对树进行旋转，即修改树中某些结点的颜色及指针结构，以达到对红黑树进行插入、删除结点等操作时，红黑树依然能保持它特有的性质（五点性质）。
如右图


#### 红黑树用处
1，广泛用于C ++的STL中，地图和集都是用红黑树实现的; 

2，着名的Linux的的进程调度完全公平调度程序，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间; 

3，IO多路复用的epoll的的的实现采用红黑树组织管理的的的sockfd，以支持快速的增删改查; 

4，Nginx的的的中用红黑树管理定时器，因为红黑树是有序的，可以很快的得到距离当前最小的定时器; 

5，Java的的的中TreeMap中的中的实现;

## 伸展树【缓存】
在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。

![image](https://img-blog.csdn.net/20180416230301124?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nhbm90/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## k-d树【空间搜索】
　k-d树（k-dimensional树的简称），是一种分割k维数据空间的数据结构。主要应用于多维空间关键数据的搜索（如：范围搜索和最近邻搜索）。
　
![image](F463237B9DD44A78A00519318AC83939)
　
## PR 四分树【图像传输用到】

![image](http://media.openjudge.cn/images/1610_1.jpg)

递归拆成1/4

我们一般都将二进制图片存成图2(d)这样的四分树的形式，这棵树是通过图2(c)里面的划分得到的。图2(d)里面的每一个结点都代表图2(c)里面的矩阵，而树的根结点代表整个大的矩阵。如果树中一个结点的值为1，则代表这个结点对应的矩阵需要划分成4个小矩阵。否则，这个结点将包含两个数。第一个数为0，表示不用再划分，第二个数为0或者1，表示整个矩阵都是这个值。整棵树可以用它的宽度优先遍历得到的结果来表示，如图2(d)中的树可以表示成(1)(0,0)(1)(0,1)(1)(0,0)(0,1)(1)(0,0)(0,0)(0,0)(0,1)(0,1)(0,0)(0,1)(0,0)(0,1)。删掉括号和逗号，我们可以得到一个更简短的纯二进制编码100101100011000000010100010001来编码这张图片，它的16进制形式为258C0511。




