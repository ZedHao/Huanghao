[toc]
八大算法思想分别是：枚举、递推、递归、分治、贪心、试探法、动态迭代和模拟算法思想
# 枚举法（穷举）
 最笨 没效率
# 递推法

## 正向递推【条件推结果】
给定一个数的序列H0,H1,…,Hn,…若存在整数n0，使当n>n0时,可以用等号(或大于号、小于号)将Hn与其前面的某些项Hi(0<i<n)联系起来，这样的式子就叫做递推关系。
```
//用顺推法解决“斐波那契数列”问题 阶乘
public class shuntuirabbit {
    public static void main(String[] args){
        int a[]=new int[24];//定义一个存放24个月的数组
        a[0]=a[1]=1;
        for(int i=0;i<24;i++){
            if(i==0||i==1)
            System.out.println("第"+(i+1)+"个月兔子的数量为"+1+"对");
            else{
                a[i]=a[i-1]+a[i-2];
                System.out.println("第"+(i+1)+"个月兔子的数量为"+a[i]+"对");
            }
        }
    }
}

用顺推法解决“斐波那契数列”问题
```

## 逆向递推【结果推条件】
 1.从原点出发，一步只能向右走、向上走或向左走。恰好走N步且不经过已走的点共有多少种走法？
 从结果分析，当前走的这一步的方向，是上，就有三种走法，是左右就只有两种，递归求解
```

```
# 递归
使用递归算法时，应注意以下几点：

（1）递归时在过程或函数中调用自身的过程。

（2）在使用递归策略时，必须有一个明确的递归结束条件，这称为递归出口。

（3）递归算法通常显得很简洁，但是运行效率较低，所以一般不提倡使用递归算法设计程序。

（4）在递归调用过程中，系统用栈来存储每一层的返回点和局部量。如果递归次数过多，则容易造成栈溢出，所以一般不提倡用递归算法设计程序。

## 【递推和递归的差异】

递推多想是多米诺骨牌，根据前面几个得到后面的；

递归是大事化小，比如汉诺塔（Hanoi）问题，就是典型的递归。


# 分治法（典型 希尔排序 二分法）
使用分治算法解题的一般步骤：

（1）分解：将要解决的问题划分成若干个规模较小的同类问题；

（2）求解：当子问题划分得足够小时，用较简单的方法解决；

（3）合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。
例子：求123456*456321的积
![image](https://img-blog.csdn.net/20161203164009671)
（1）二分搜索

## （2）大整数乘法
例子：求123456*456321的积
![image](https://img-blog.csdn.net/20161203164009671)
（3）Strassen矩阵乘法

##（4）棋盘覆盖

 在一个2^k×2^k 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。
　　
　　
　　![image](http://images.cnitblog.com/blog/328951/201306/14220958-a1cb3c8a13174c96901a174c1c04cd99.x-png)
　　
（5）合并排序

（6）快速排序

（7）线性时间选择

## （8）最接近点对问题

给定平面上n个点，找其中的一对点，使得在n个点的所有点对中，该点对的距离最小。严格地说，最接近点对可能多于1对。为了简单起见，这里只限于找其中的一对。

拆成两个子集和
（9）循环赛日程表

（10）汉诺塔
# 贪心思想

弹性算法的基本过程：

（1）从问题的某一个初始解出发；

（2）While能向给定总目标前进一步；

（3）求出可行解的一个解元素；

（4）由所有解元素组成问题的一个可行解。


```
  从问题的某一初始解出发；
    while （能朝给定总目标前进一步）
    { 
          利用可行的决策，求出可行解的一个解元素；
    }
    由所有解元素组合成问题的一个可行解；
```
## 背包问题

有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。

要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。

物品 A  B  C  D  E  F  G

重量 35 30 60 50 40 10 25

价值 10 40 30 50 35 40 30

记得当时学算法的时候，就是这个例子，可以说很经典。

分析：

目标函数： ∑pi最大

约束条件是装入的物品总重量不超过背包容量，即∑wi<=M( M=150)

（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？

（2）每次挑选所占重量最小的物品装入是否能得到最优解？

（3）每次选取单位重量价值最大的物品，成为解本题的策略?

## 最大整数
设有n个正整数，将它们连接成一排，组成一个最大的多位整数。

例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。

又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。

输入：n

N个数

输出：连成的多位数

算法分析：此题很容易想到使用贪心法，在考试时有很多同学把整数按从大到小的顺序连接起来，测试题目的例子也都符合，但最后测试的结果却不全对。按这种标准，我们很容易找到反例：12，121应该组成12121而非12112，那么是不是相互包含的时候就从小到大呢？也不一定，如12，123就是12312而非12123，这种情况就有很多种了。是不是此题不能用贪心法呢？

其实此题可以用贪心法来求解，只是刚才的标准不对，正确的标准是：先把整数转换成字符串，然后在比较a+b和b+a，如果a+b>=b+a，就把a排在b的前面，反之则把a排在b的后面。

# 试探法算法思想【回溯法】
为了求得问题的解，先选择某一种可能情况进行试探，在试探过程中，一旦发现原来的选择的假设情况是错误的，就退回一步重新选择，继续向前试探，如此反复进行，直至得到解或证明无解。

试探法解题的基本步骤：

（1）针对所给定问题，定义问题的解空间；

（2）确定易于搜索的解空间结构；

（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。
##  彩票问题
    假设有一种彩票，每注由7个1~29的数字组成，且这7个数字不能相同，编写程序生成所有的号码组合。
    
```
//start from the very beginning,and to create greatness
//@author: Chuangwei Lin
//@E-mail：979951191@qq.com
//@brief： 29选7彩票组合
#include <stdio.h>
#define MAXN 7 //设置每一注彩票的位数 
#define NUM 29 //设置组成彩票的数字 
int num[NUM];
int lottery[MAXN];
/******************************************************
函数名：combine(int n, int m)
参数：组成彩票的数字，每一注彩票的位数
功能：29选7彩票组合
*******************************************************/
void combine(int n, int m)
{
     int i,j;//n最开始为29，m为7
     for(i=n;i>=m;i--)
     {
         lottery[m-1]=num[i-1];//保存一位数字,第一位是29
         if (m>1)
             combine(i-1,m-1);
         else //若m=1,输出一注号码 
         {
             for(j=MAXN-1;j>=0;j--)
                 printf("%3d",lottery[j]);
             printf("\n");
         }
     }
}
int main()
{
    int i,j;
    for(i=0;i<NUM;i++)  //设置彩票各位数字 
        num[i]=i+1;//num={1,2,3...29}
    for(i=0;i<MAXN;i++)
        lottery[i]=0;
    combine(NUM,MAXN);    
    return 0;
}

```

# 模拟退火算法思想

　　下面介绍退火算法（SA,Simulated Annealing）。

　　首先拿爬山做例子：我们要找到山脉的最高峰，但是我（计算机）只能看到我的脚下哪边是上升的，哪边是下降的，看不到远处是否上升。每次移动，我们随机选择一个方向。如果这个方向是上升的的（更优），那么就决定往那个方向走；如果这个方向是下降的（更差），那么“随机地接受”这个方向，接受就走，不接受就再随机一次——这个随机是关键，要考虑很多因素。比如，一个陡的下坡的接受率要比一个缓的下坡要小（因为陡的下坡后是答案的概率小）；同样的下降坡度，接受的概率随时间降低（逐渐降低才能趋向稳定）。
　　
　　![image](https://images2015.cnblogs.com/blog/1009785/201611/1009785-20161116200146560-799082386.png)
　如果坚决不接受一个更差的解，那么就会卡在上面的“当前位置”上了。倘若接受多几次更差的解，让他移动到山谷那里，则可以突破局部最优解，得到全局最优解。

既然这个随机这么重要，那么我们就将它写为一个函数：

```
bool accept(double delta, double temper){
    if(delta <= 0) return true;
    return rand() <= exp((-delta) / temper) * RAND_MAX;
} 
```
其中delta是新答案的变化量，temper是当前的“温度”。温度是模拟退火算法的一个重要概念，它随时间的推移缓慢减小。我们来分析一下这个代码：

if(delta <= 0) return true;

　　由于答案越小越优，因此当温度的变化量小于零（新答案减小）时，新解比旧解优，因此返回“接受”

return rand() <= exp((-delta) / temper) * RAND_MAX;

　　RAND_MAX是rand()的最大值。为了保证跨平台、跨编译器甚至跨版本时的正常运作，我们不对其作出任何假定。

　　我们把它移项：return (double)rand() / RAND_MAX <= exp((-delta) / temper)。在右边，temper是正数，delta是正数（delta是负数的已经return出去了），因此exp()中间的参数是负数。我们知道，指数函数在参数是负数时返回(0, 1)——这就是接受的概率。我们在左边随机一个实数，如果它比概率小，就接受，否则就不接受。
　　
# 遗传算法
遗传算法，核心是达尔文优胜劣汰适者生存的进化理论的思想。

我们都知道一个种群，通过长时间的繁衍，种群的基因会向着更适应环境的趋势进化，牛B个体的基因被保留，后代越来越多，适应能力低个体的基因被淘汰，后代越来越少。经过几代的繁衍进化，留下来的少数个体，就是相对能力最强的个体了。

那么在解决一些问题的时候，我们能不能学习这样的思想，比如先随机创造很多很多的解，然后找一个靠谱的评价体系，去筛选比较好的解，再用这些好的解像生小宝宝一样生一堆可能更好的解，然后再筛再生，反复弄个几代，得到的说不定就是近似最优解哟


# 蚁群算法

蚂蚁在运动过程中，会留下一种称为信息素的东西，并且会随着移动的距离，播散的信息素越来越少，所以往往在家或者食物的周围，信息素的浓度是最强的，而蚂蚁自身会根据信息素去选择方向，当然信息素越浓，被选择的概率也就越大，并且信息素本身具有一定的挥发作用。 蚂蚁的运动过程可以简单归纳如下：

当周围没有信息素指引时，蚂蚁的运动具有一定的惯性，并有一定的概率选择其他方向
当周围有信息素的指引时，按照信息素的浓度强度概率性的选择运动方向
找食物时，蚂蚁留下家相关的A信息素，找家时，蚂蚁留下食物相关的B信息素，并随着移动距离的增加，洒播的信息素越来越少
随着时间推移，信息素会自行挥发
一个简单的例子，如果现在有两条通往食物的路径，一条较长路径A,一条较短路径B,虽然刚开始A,B路径上都有蚂蚁，又因为B比A短，蚂蚁通过B花费的时间较短，随着时间的推移和信息素的挥发，逐渐的B上的信息素浓度会强于A，这时候因为B的浓度比A强，越来越多多蚂蚁会选择B，而这时候B上的浓度只会越来越强。如果蚂蚁一开始只在A上呢，注意蚂蚁的移动具有一定小概率的随机性，所以当一部分蚂蚁找到B时，随着时间的推移，蚂蚁会收敛到B上，从而可以跳出局部最