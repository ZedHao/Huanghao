
# linux 是怎么识别命令的
1. /dev/stdin：标准输入文件
   程序开始运行时，默认会调用open("/dev/stdin", O_RDONLY)将其打开，返回的文件描述符是0
   
   使用0这个文件描述符，可以从键盘输入的数据简单理解就是，/dev/stdin这个文件代表了键盘。
   
   read(0, buf, sizeof(buf))实现的是什么功能
   
   从键盘读取数据到到缓存buf中，数据中转的过程是：
   
   read应用缓存buf <—————— open /dev/stdin时开辟的内核缓存 <——————键盘驱动程序的缓存 <——————键盘
2. 用程序通过OS API操作底层硬件时，都是以文件形式来操作的，不管是读键盘，还是向显示器输出文字显示，都是以文件形式来读写的，在Linux下有句很经典的话，叫做“在Linux下一切皆文件”。
3. 程序开始运行时，默认open("/dev/stdout", O_WRONLY)将其打开，返回的文件描述符是1为什么返回的是1，先打开的是/dev/stdin，把最小的0用了，剩下最小没用的是1，因此返回的肯定是1。
# dev 下面都是干嘛的 
/dev这个目录对所有的用户都十分重要。因为在这个目录中包含了所有Linux系统中使用的外部设备。
# 理解进程和线程

# 理解fork 进程
操作系统就是一堆进程，每个进程都是已有进程创建出来的
操作系统的运行就是进程的不断创建和销毁的过程。
fork 即为叉子 
1. 进程资源全部拷贝一遍，cs：eip指向新进程的指令部分。
2. fork给父进程返回子进程pid，给其拷贝出来的子进程返回0
3. 会有一个init进程，通过这个init进程fork出一个子进程，这个子进程就专门来处理我们的shell。
        `vfork 和 fork的区别
        vfork与fork相似，但是也有区别,具体区别归结为以下3点：
        
        fork() 子进程拷贝父进程的数据段，代码段. vfork() 完全和父进程共享内存，包括堆、BSS、初始化非0数据区等区域。
        
        fork() 父子进程的执行次序不确定. vfork():保证子进程先运行。
        
        为什么要使用 vfork？
        因为以前的fork当它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，而往往在子进程中会执行exec调用，这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了vfork`
    ### fork() 含义
    https://zhuanlan.zhihu.com/p/91616048
    相当于调用fork的进程 存储啥的都复制一遍，进程从fork节点新执行，共享存储   父进程与子进程的执行顺序是我们无法确定的（即调度进程使用CPU）  
    https://zhuanlan.zhihu.com/p/73859876