[toc]
# 调度
## 什么是调度
当计算机系统死多道程序设计系统时，==通常就会有多个进程或者线程竞争CPU，只要有两个或者更多的进程处于就绪状态，这种情况就会发生，如果只有一个CPU可以用，那么必须选择下一个要运行的进程==，在操作系统中，完成选择工作的这一部分被称为调度程序（scheduler）。该程序使用的算法称为调度算法（scheduler algorithm）。

![image](https://images2015.cnblogs.com/blog/798615/201704/798615-20170407233049253-1948553968.png)
## 什么时候调度
1. 在创建一个新进程后，需要决定是运行父进程还是子进程
1. ==一个进程退出后必须进行调度==
1. 在一个进程阻塞在I/O和信号量上或者由于其他原因阻塞的时候，必须选择另一个进程开始运行。
1. 在一个I/O发生中断的时候，必须做出调度决策。
1. 非抢占式调度：挑选一个进程，然后让该进程运行到被阻塞。
1. 抢占式调度：挑选一个进程让他运行到某个固定时段的最大值。如果在改时间段结束时，该进程仍然在运行，它就会被挂起，而调度程序挑选另一个进程运行，如果存在一个就绪进程。进行抢占式调度处理，需要在事件间隔的末端发生时钟中断，以便把CPU控制返回给调度程序，如果没有可用的时钟，那么非抢占式调度就是唯一的选择。
##  调度的目标
- 吞吐量 (throughout) : 系统每个小时完成的作业数量。
- 周转时间 (turnaround time) : 一个批处理作业提交时刻到完成该作业完成时刻为止的统计平均时间。
- CPU利用率 (CPU Utilization) : 多用于度量批处理系统，反应CPU的使用情况
## 处理器调度
### 处理器调度的层次
#### 低级调度：进程调度，决定哪个可用进程占用处理器执行
就绪态->运行态
1. 低级调度的主要功能：
1. 记住进程或者内核级线程的状态
1. 决定某个进程或者内核级线程什么时候获得处理器，以及占用多长时间
1. 吧处理器分配给进程或者内核级线程
1. 收回处理器
2. 
中级调度：

平衡负载调度，决定主存中的可用进程集合，把一些进程调至外存去等待
挂起就绪态->就绪态

高级调度：作业调度，决定能否加入到可执行的进程池中

新建态->挂起就绪态/就绪态
## 调度算法
### 批处理系统中的调度
#### FCFS(先来先服务，队列实现，非抢占的)：
先请求CPU的进程先分配到CPU

==有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。==
#### SJF(最短作业优先调度算法)：
平均等待时间最短，但难以知道下一个CPU区间长度

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。如果一直有短作业到来，那么长作业永远得不到调度。
#### 最短剩余时间优先 (shortest remaining time next)
这个算法是最短作业优先算法的抢占式的版本，使用这个算法的时候，调度程序总是选择则剩余运行时间最短的那个进程运行。再次提醒，有关的运行时间必须提前掌握。当一个新的作业到达打的时候，其整个时间同当前进程的剩余时间进行比较。其进程的运行时间必须被提前知道，当一个新的作业到达的时候，其整个时间同当前进程的剩余时间作比较。如果较新的进程比当前运行的进程需要更少的时间，当前进程就会被挂起，而运行新的进程。这种方式可以使新的短作业获得良好的服务。
### 交互式系统中的调度【例如有键盘IO的】
#### 优先级调度算法(可以是抢占的，也可以是非抢占的)：
优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化

除了可以手动赋予优先权之外，还可以把响应比作为优先权，这种调度方式叫做高响应比优先调度算法。

响应比 = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间
![image](https://images2015.cnblogs.com/blog/798615/201704/798615-20170407233130269-853882980.png)

上图的算法一目了然，就是把所有的进程分为四个优先级组，而在各类进程的内部采用轮转调度。如图3，只要存在优先级为4的进程，则不会理会优先级3，2，1的进程。当优先级4的队列为空后，才开始调度优先级3的进程。以此类推。
 
动态优先级调度要每隔一段时间调整进程的优先级，否则会发生饥饿。同时也要注意锁封护和优先级反转的问题。

这种调度算法主要是为了解决 SJF 中长作业可能会饿死的问题，因为随着等待时间的增长，响应比也会越来越高。
#### 时间片轮转调度算法(可抢占的)：
队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。
![image](https://images2015.cnblogs.com/blog/798615/201704/798615-20170407233102457-1541861276.png)

时间片轮转算法的效率和时间片有很大关系。因为每次进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太短，进程切换太频繁，在进程切换上就会花过多时间。

#### 多级队列调度算法：
将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。

#### 多级反馈队列调度算法：
与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。
### 实时系统中的调度【例如 多媒体实时系统】
![image](https://images2015.cnblogs.com/blog/798615/201704/798615-20170407233210675-1143570352.png)

在实时系统中我们可以尝试设置一个主控时钟，该时钟每秒滴答适当的次数，例如针对NTSC制式的视频，每秒滴答30次，在时钟的每一个触发下，所有的进程都以相同的次序相继运行，当一个进程完成其工作时，它将发出suspend系统调用释放CPU直到主控时钟再次触发。当主控时钟再次响应，所有的进程再次以相同的次序运行。只要进程数较少，所有的工作都可以在一帧的时间内完成。采用轮转调度就可以了。但是模型相当不靠谱，因为不同的进程可能以不同的频率运行，具有不用的工作量，并且具有不同的最终时限。
#### 速率单调调度（实时静态算法）
####  最早最终时限调度（实时动态算法）

### 线程调度
线程调度主要是分为用户级线程调度和内核级线程调度，他们的区别就是在于内核是否认识到有不同的线程，如下图所示：
![image](https://images2015.cnblogs.com/blog/798615/201704/798615-20170407233314160-1846999872.png)
## Linux任务调度
linux将进程分成实时进程和普通进程，其实时进程应先于普通进程运行。
对于实时进程，采用FIFO和RR（时间片轮转调度）
对于普通进程，采取动态优先调度
系统中进程调度策略有哪几种？

FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU

SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度

优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化

时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。

多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。

多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。
