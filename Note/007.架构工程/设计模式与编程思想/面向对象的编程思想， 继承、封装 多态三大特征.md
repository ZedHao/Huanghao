[toc]
# 面向对象 oo  VS 面向过程 op
https://zhuanlan.zhihu.com/p/28427324
例如设计一个五子棋
## op面向过程 
（1）开始游戏（2）黑子先走（3）绘制画面（4）判断输赢（5）轮到白子（6）绘制画面（7）判断输赢（8）返回步骤（2） （9）输出最后结果。

用函数实现上面一个一个的步骤，然后在下五子棋的主函数里依次调用上面的函数（不同的编程语言有不同的调用方法，我这里写的是直接调用）：

下五子棋{

开始游戏（）；

黑子先走（）；

绘制画面（）；

判断输赢（）；

轮到白子（）；

绘制画面（）；

判断输赢（）；

返回到 黑子先走（）；

输出最后结果；

}
可见，面向过程始终关注的是怎么一步一步地判断棋局输赢的，通过控制代码，从而实现函数的顺序执行。

## oo 面向对象
在下五子棋的例子中，用面向对象的方法来解决的话，首先将整个五子棋游戏分为三个对象:

（1）黑白双方，这两方的行为是一样的。

（2）棋盘系统，负责绘制画面

（3）规则系统，负责判定犯规、输赢等。

然后赋予每个对象一些属性和行为：

（4）第一类对象（黑白双方）负责接受用户输入，并告知第二类对象（棋盘系统）棋子布局的变化，棋盘系统接收到了棋子的变化，并负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。

可以看出，面向对象是以功能来划分问题，而不是以步骤解决。比如绘制画面这个行为，在面向过程中是分散在了多个步骤中的，可能会出现不同的绘制版本，所以要考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘系统这个对象中出现，从而保证了绘图的统一。



## 举例说明两者的优缺点
比如在五子棋游戏中增加悔棋的功能。在面向过程中，从输入到显示再到最后判断的整个步骤都要改动，甚至函数的调用顺序也要改动，而在面向对象的设计中，只需在棋盘系统中增加一个回溯的功能就可以了，黑白双方和规则系统的属性和行为都不需改动。这个例子说明了面向对象程序设计中代码间的相关性低（低耦合特性），使得代码很容易被复用和扩展，同时也说明了面向过程的代码重用性低、扩展能力差。
## 例二
比如我从冰箱拿饮料，面向过程要定义三个分离的函数：f1（我的右手，冰箱）: 我右手打开冰箱； f2(我的左手，饮料)：我左手拿出饮料；f3(我的右手，冰箱)：我右手关上冰箱。面向对象就是定义一个对象"我"，我有两个属性：左手，右手，三个方法：打开冰箱；拿出饮料；关上冰箱。这三个方法中，可以直接通过self.左手，self.右手 去实现，而不需要"在打开冰箱"时还要传一个参数为：我的左手
## 例三
a. 面向过程：定义上学这个过程，如果有小红，二蛋，大傻等10个人呢，他们上学方式一样还好，如果有坐车的，有走路的不一样，就得定义10个上学的过程分别对应 
b. 面向对象，定义一个人（或学生），定义一个上学方法，如果是10个人，最多在这个学生中定义10个方法。 
c. 如果在上学途中，小明想买冰棒，想泡妞，怎么办？面向过程就得添加买冰棒，泡妞这个过程，而面向对象，只需在学生类中添加 泡妞，买冰棒的方法 
# 继承 封装  多态
## 封装 其实就是面向对象oo的思想

　　　　A.定义：
　　　　==封装就是将抽象得到的数据和行为相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成类==，其中数据和函数都是类的成员，目的在于将对象的使用者和设计者分开，以提高软件的可维护性和可修改性

　　　　B.特性：
- 　　　　1. 结合性，即是将属性和方法结合   
- 　　　　2. 信息隐蔽性，利用接口机制隐蔽内部实现细节，只留下接口给外界调用   
- 　　　　3. 实现代码重用
## 继承   

　　　　定义：继承就是新类从已有类那里得到已有的特性。 类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，

　　　子类继承基类后，可以创建子类对象来调用基类函数，变量等

- 　　　单一继承：继承一个父类，这种继承称为单一继承，一般情况尽量使用单一继承，使用多重继承容易造成混乱易出问题(php)
- 　　　多重继承：继承多个父类，类与类之间要用逗号隔开，类名之前要有继承权限，假使两个或两个基类都有某变量或函数，在子类中调用时需要加类名限定符如c.a::i = 1；(C++)
- 　　　菱形继承：多重继承掺杂隔代继承1-n-1模式，此时需要用到虚继承，例如 B，C虚拟继承于A，D再多重继承B，C，否则会出错
- 　　　继承权限：继承方式规定了如何访问继承的基类的成员。继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限
- 　　  继承权限：子类继承基类除构造和析构函数以外的所有成员

　　　　继承也分为接口继承和实现继承：

　　　　　　普通成员函数的接口总是会被继承：　　子类继承一份接口和一份强制实现

　　　　　　普通虚函数被子类重写　　　　　：　　子类继承一份接口和一份缺省实现

　　　　　　纯虚函数只能被子类继承接口　　：　　子类继承一份接口，没有继承实现
　　　　　　
　　　　　　![image](https://images2015.cnblogs.com/blog/1048430/201611/1048430-20161107095657280-1519112029.png)
　　　　　　
## 多态
三大特征：

子类继承父类
子类重写父类
父类指向子类

举个模型例子，一家公司有员工类（Employee），还有其子类：销售（Sales）、市场（Market）、工程师（Engineer）等。某一天老板招待所有的员工开了个短会，完了之后对所有的员工（Employee）说，大家回去工作吧。在这里我们可以认为老板调用了所有员工对象的continueToWork()方法，而不是对一个个员工细说做什么工作，比如对销售部说你去制定销售计划（调用makeSalePlan();），对市场部说你去制定产品的价格（调用makeProductPrice();）….这种逐个细说的方式并不是面向对象，而是面向个体。可以确定的是，员工类应该有一个方法continueToWork()。而员工如何实现他们工作的方法却只有精确到子类才能确定，因为不同的员工的工作方式是不一样的。因此，我们很多时候只需要关心对象的父类型，而忽略更精确的子类型，比如上面老板叫大家回去工作时，他对全体员工说的，主要指的是全体员工类型。 


```
<?php
abstract class Employee{
    abstract function continueToWork();
}
class Sales extends Employee{
    private function makeSalePlan(){
        echo "make sale plan";
    }

    public function continueToWork(){
        $this->makeSalePlan();
    }
}

class Market extends Employee{
    private function makeProductPrice(){
        echo "make product price";
    }

    public function continueToWork(){
        $this->makeProductPrice();
    }
}

class Engineer extends Employee{
    private function makeNewProduct(){
        echo "make new product";
    }

    public function continueToWork(){
        $this->makeNewProduct();
    }
}

class Demo{
    public function Work($employeeObj){
        $employeeObj->continueToWork();
    }
}
//调用
$obj = new Demo();
$obj->Work(new Sales());
$obj->Work(new Market());
$obj->Work(new Engineer());
?>

```



