[TOC]
# 递归为什么开销大 效率和开销问题是递归最大的缺点
![image](http://www.nowamagic.net/librarys/images/201210/2012_10_18_02.jpg)
从上图可以看出，在计算Fib(5)的过程中，Fib(1)计算了两次、Fib(2)计算了3次，Fib(3)计算了两次，本来只需要5次计算就可以完成的任务却计算了9次。这个问题随着规模的增加会愈发凸显，以至于Fib(1000)已经无法再可接受的时间内算出

# 线性表 栈和队列 
https://blog.csdn.net/xmxkf/article/details/82465726#15-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8
# 栈【先进后出】
栈是一种最常用也是最重要的数据结构质疑，用途十分广泛。==在二叉树的各种算法中大量地使用栈，将递归算法转换成非递归算法时也常常用到栈；==
## 具体应用
### 破解迷宫
  给定一个M * N的迷宫图，求一条从指定入口到出口的路径。假设迷宫图如下图所示，白色表示通道，深色表示墙。所求路径必须是简单路径，即路径中不能重复出现同一通道块。为了表示迷宫，设置一个二维数组maze，其中每个元素表示一个方块的状态，0表示是通道，1表示该方块不可走
![image](https://img-blog.csdn.net/2018090617503481?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNjM0NDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
在求解时，通常使用“穷举求解”的方法，即从入口出发，顺某一方向向前试探，若能走通，则继续往前走，否则眼原路退回，换一个方向在继续试探，直到所有可能的通道都试探完为止。

  为了保证在任何为止上都能沿原路退回，需要用一个后进先出的栈来保存从入口到当前位置的路径。每次取栈顶的方块，试探这个方块下一个可走的方向（上方、右方、下方、左方），如果找到可走的方向，则将该方向下一个方块入栈，如果没有可走的下一个方块，说明该路死了，需要将当前栈顶元素出栈。为了保证试探的可走相邻方块不是已走路径上的方块，比如（i,j）已经入栈，在试探（i+1, j)的下一可走方块时又试探到（i,j），这可能会引起死循环，为此，在一个方块入栈后，将对应数组元素值改为-1（只有0才是可走），当出栈时，再将其恢复至0。
### 用于符号匹配。
在编译器的语法检查中，一个过程就是检查各种括号是否匹配，比如 ([]) ，这就是匹配的，而 {[}] 就不匹配了。可以用堆栈来实现括号匹配。
```
while( 文件没有结束 ) {
        读取一个字符。
        if 遇到一个左括号，把它入栈。
        else if 遇到右括号 then 检查堆栈，{
            if 堆栈为空 then 报告错误，终止程序（括号不匹配）。
            else if 堆栈非空 then {
                if 栈顶不是对应的左括号 then 报错，终止程序。
                弹出栈顶。
            }
     }
    if 栈非空 then 报错。
```
### 用于计算代数式。( 也可以用二叉树来解决 )
 
如果我们要计算 6 + 4 * 8 ，要考虑到优先级的问题，这时候就可以用到堆栈了。
先要把代数式构造成 6 4 8 * + （构造方法也是用堆栈，在下一条会讲到）。逐个读取数据，当读到数字时， 把数字入栈，
读到运算符时，弹出栈中的两个元素（因为这里的是二元运算符，所以弹出两个，如果是sin等一元运算符就弹出一个），根据读取
的运算符执行运算，把结果压入栈中，然后继续读取数据，读取结束后栈顶元素就是结果。
比如读取6，4，8，由于是数字，所以依次入栈，
读到 "*" 时，弹出 4 和 8，相乘得到 32，把32入栈。读到 "+" 时，
弹出 6 和 32 ，执行运算得到 38，压入栈中，接着读取结束，栈顶的 38 就是结果。


### 构造表达式。( 也可以用二叉树来解决 )
 
比如一个正常的代数式（叫他infix）, a + b * c + ( d * e + f ) * g , 转化成表达式 a b c * + d e * f + g * +, 这个表达式我们叫他 postfix。
把postfix按照 2 中的算法计算就能得到正确的计算顺序。
 
先规定优先级，加减的优先级最低，左括号优先级最高
### 用于函数调用
 
因为CPU一次只能执行一个命令，而寄存器也是公用的，
当前函数 current() 在运行时，数据储存在寄存器中，如果要调用另外一个函数 target()，而target() 也要求使用寄存器，为了防止数据丢失并且在执行完 target()
能够返回到 current() 继续执行, 这时候就要把当前函数的重要数据储存起来，压入内存中的栈中( 包括变量的值和函数地址 )。这样target()函数就可以无所顾忌的使用寄存器了。
target() 函数执行结束就取栈顶的返回地址继续执行 current()。如果target()中又调用另外一个函数，相应的操作也是一样的。
 
这种机制和括号匹配有点相似，函数调用就像遇到了一个左括号，函数返回就像遇到一个右括号。
 
这种机制就是递归的原理。递归返回地址就是自己。（这句话可能有问题，我就是这么理解的）。
 
栈的空间有限，如果递归没有结束条件，就会不断的压栈，然后栈溢出，程序出错。

# 队列 先进后出
在1.5中使用栈来破解迷宫，是利用穷举的思想，尝试沿着一条路走下去，走不通回退，继续尝试下一条路，直到找到出口。通过这种方式求出的路径不一定是最短路径，这跟尝试的方向有关系（上左下右），如果向上走时能一直走到出口，则会忽略掉左下右等方向的更短的路径。 
  这里我们使用队列来求解，假设当前点位为（x, y），在队列中的索引为front，遍历该位置的四个方位，如果方位可走则入队，并记录这个方位元素的前驱为front。如下图所示，当前点位上方的点位不可走，不入队；右方可走，入队；下方可走入队；左方可走入队；然后将front++，这时候当前点位变成（x, y+1），继续遍历它的四个方位，淘汰掉不可走的，可走的方位都会入队……。这样一层一层向外扩展可走的点，所有可走的点位各个方向都会尝试，而且机会相等，直到找到出口为止，这个方法称为“广度优先搜索方法”。然后我们从出口反向找其上一个方块的下标，直到下标为0，这个反向过程就能找到最短路径。由于此处需要通过索引获取队列元素，所以使用顺序队列来实现，因为链式存储结构查找不方便。
