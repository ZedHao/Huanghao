[TOC]
# 加密算法 
## 加密算法分类

### 对称加密
DES
3DES
AES
### 非对称加密
因为 加密 和 解密 使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。

例子：甲方生成 一对密钥 并将其中的一把作为 公钥 向其它人公开，得到该公钥的 乙方 使用该密钥对机密信息 进行加密 后再发送给甲方，甲方再使用自己保存的另一把 专用密钥 (私钥)，对 加密 后的信息 进行解密。
![image](https://user-gold-cdn.xitu.io/2018/7/13/16493f2bfa06e955?w=736&h=214&f=png&s=37513)
RSA
 基于一个十分简单的数论事实：将两个大 素数 相乘十分容易，但想要对其乘积进行 因式分解 却极其困难，因此可以将 乘积 公开作为 加密密钥。
ECC
### 散列（hash）算法
SHA-1
SHA1 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 2 ^ 64 位的消息，SHA1 会产生一个 160 位的 消息摘要。基于 MD5、SHA1 的信息摘要特性以及 不可逆 (一般而言)，可以被应用在检查 文件完整性 以及 数字签名 等场景。

MD5
MD5 用的是 哈希函数，它的典型应用是对一段信息产生 信息摘要，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 摘要算法。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。
==彩虹表 暴力破解==

## 常见的签名加密算法 
### MD5算法
### SHA1算法
### HMAC算法
### AES/DES/3DES算法
### RSA算法
### ECC算法

https://blog.csdn.net/tengxy_cloud/article/details/52808163
https://www.cnblogs.com/zhangshitong/p/6478721.html
https://www.cnblogs.com/andy-zhou/p/5360107.html
# ssl证书
## ssl 用法过程
https://blog.csdn.net/tengxy_cloud/article/details/52808163
![image](https://mc.qcloudimg.com/static/img/d242c611c463a59c822038f2ded8b1bb/image.png)
假设一个公司B company向证书机构xxx CA申请SSL证书，他会得到一张类似下面这张图的证书


B company得到这张证书后，会在与用户通信的过程中将证书发送给用户，用户首先会检测办法证书的机构，如果是大家都公认的证书机构，操作系统在出厂时会内置这个机构的机构信息和公钥，例如xxx CA，如果是一个不受信任的证书机构，应用程序（比如浏览器）会发出警告，如果是受信任的证书机构，应用程序会使用预置的xxx CA的公钥去解密最后的指纹内容和指纹算法，然后再把前面的证书内容用指纹算法计算后与指纹内容比对，由于指纹内容是由证书机构唯一的私钥加密的，因此只要比对成功说明证书是没有人被人修改过的。接下来用户就可以放心使用该公司的公钥了
## ssl 的产生过程 
1.最简单的通信过程

![image](https://mc.qcloudimg.com/static/img/9afa58403a75f46ed35d74416ed43cd0/image.png)
2.确认服务器身份 

![image](https://mc.qcloudimg.com/static/img/d49f649a1ba1e0fb72c539634cb43670/image.png)
其中“（）”里的内容是服务器用私钥加密后的内容，一般服务器会将明文加密，浏览器在收到消息后首先会用公钥解密密文，由前面特性3可以知道，公钥和解密算法是可以解出明文的，如果解不出来说明对方不是目标服务器，确认服务器身份后，在向服务器发送数据的过程中，如果数据被黑客截获，我们的用户名和密码也会落入黑客之手，于是下一步我们需要对发送的数据进行加密。


## 验证流程
1 客户端发起一个https的请求，把自身支持的一系列Cipher Suite（密钥算法套件，简称Cipher）发送给服务端

 

2  服务端，接收到客户端所有的Cipher后与自身支持的对比，如果不支持则连接断开，反之则会从中选出一种加密算法和HASH算法

   以证书的形式返回给客户端 证书中还包含了 公钥 颁证机构 网址 失效日期等等。

 

3 客户端收到服务端响应后会做以下几件事

    3.1 验证证书的合法性    

　　  颁发证书的机构是否合法与是否过期，证书中包含的网站地址是否与正在访问的地址一致等

        证书验证通过后，在浏览器的地址栏会加上一把小锁(每家浏览器验证通过后的提示不一样 不做讨论)

   3.2 生成随机密码

        如果证书验证通过，或者用户接受了不授信的证书，此时浏览器会生成一串随机数，然后用证书中的公钥加密。 　　　　　　

    3.3 HASH握手信息

       用最开始约定好的HASH方式，把握手消息取HASH值，  然后用 随机数加密 “握手消息+握手消息HASH值(签名)”  并一起发送给服务端

       在这里之所以要取握手消息的HASH值，主要是把握手消息做一个签名，用于验证握手消息在传输过程中没有被篡改过。

 

4  服务端拿到客户端传来的密文，用自己的私钥来解密握手消息取出随机数密码，再用随机数密码 解密 握手消息与HASH值，并与传过来的HASH值做对比确认是否一致。

    然后用随机密码加密一段握手消息(握手消息+握手消息的HASH值 )给客户端

 

5  客户端用随机数解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密  

     因为这串密钥只有客户端和服务端知道，所以即使中间请求被拦截也是没法解密数据的，以此保证了通信的安全