# TCP
## TCP主要特点：

1）面向连接

2）每一条TCP连接只能是点对点的。

3）TCP提供可靠交付服务。

4）提供==全双工通信==。

5）面向字节流。

 

## TCP的连接

TCP连接的端口是套接字。套接字是IP地址加端口号。

格式：socket = （IP地址：端口号）

每一条TCP连接唯一地被通信两端的两个套接字所确定。即：

TCP连接 ：：= {socket1, socket2} = {(ip1: port1), (ip2: port2)}


## TCP 三次握手和四次挥手
大白话解释：

三次握手【类似开黑】：
1.    客户端向服务器说，我要拿数据了，
1.    服务器回应说，我收到你请求了，你准备拿数据吧。
1.    客户端说：我把我要的数据起始点发给你，你发吧。
  

　在三次握手之后，A和B都能确定这么一件事==： 我说的话，你能听到； 你说的话，我也能听到 == 
   如果是两次，客户端能确定服务器能收到，但是服务器不能确定客户端是否能收到

四次挥手：
1.       客户端给服务器说：我不要数据了
1.       服务器为了确认：我准备好了
1.       ''过了一会''
1.       服务器：我准备切停数据了，
1.       客户端：好吧，你切吧 
      

![image](https://upload-images.jianshu.io/upload_images/1293297-15fd6d0a3851bbc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/258/format/webp)
### 三次握手

![image](https://img-blog.csdn.net/20180621174506805?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzY0OTk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
1.B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程就处于LISTEN状态，等待客户的连接请求。

2.A的TCP客户进程也是首先创建传输控制块TCB，然后向B发送连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq = x。TCP规定，SYN报文段不能携带数据（即SYN=1的报文段），但要消耗掉一个序号。这时，TCP客户端进入SYN-SENT（同步已发送）状态。

3.B收到连接请求报文后，如同意连接，则向A发送确认。在确认报文段中应把SYN和ACK都置1，确认号是ack=x+1，然后也为自己选择一个初始序号seq=y。请注意这个报文也不能携带数据，但是要消耗一个序号。这时TCP服务器进程进入SYN-RCVD（同步收到）状态。

4.TCP客户进程收到B的确认后，还要向B发送确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1.TCP的标准规定，ACK报文可以携带数据，但如果不携带数据则不消耗序号，在这种情况下，下一个报文的序号仍是seq=x+1.这时，TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态。

5.当B收到A的确认后，也进入ESTABLISHED状态。
### 四次挥手
![image](https://img-blog.csdn.net/20160926193227287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

1. 第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
1. 第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
1. 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
1. 第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

通俗理解：
- 1，当主机甲确认发送完数据且知道乙已经接受完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给主机B.
- 
- 2，主机乙收到甲发送的FIN，表示收到了，就会发送ACK回复。
- 
- 3，但这是乙可能还在发送数据，没有想要关闭数据口的意思，所以FIN与ACK不是同时发送的，而是等到乙数据发送完了，才会发送FIN给主机A.
- 
- 4，A收到B发来的FIN，知道B的数据也发送完了，回复ACK，A等待2MSL以后，没有收到B传来的任何消息，知道B已经收到自己的ACK了，A就关闭链接，B也关闭链接了。


# UDP
5.3用户数据报协议UDP

UDP只在IP数据报服务之上增加了复用分用以及差错检测的功能。

主要特点：

1）无连接的

2）尽最大努力交付

3）UDP是面向报文的。发送发的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。

4）UDP没有拥塞控制。因此网络出现拥塞不会使源主机的发送速率降低。这对如IP电话、实时视频会议的实时应用很重要。这些应用要求源主机以恒定的速率发送数据。并且允许在网络发生拥塞时丢失一些数据，但不允许数据有太大时延。

5）UDP支持一对一、一对多、多对一、多对多的交互通信。

6）UDP的首部只有8字节，开销小。

# UDP TCP 比较