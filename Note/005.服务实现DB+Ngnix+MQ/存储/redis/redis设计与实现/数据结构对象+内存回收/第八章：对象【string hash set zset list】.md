[TOC]
# 基本结构
Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三 个属性分别是type属性、encoding属性和ptr属性：
![image](https://images2017.cnblogs.com/blog/960295/201801/960295-20180105135112284-2020472360.png)

# 底层实现
对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding 属性决定。
encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为 对象的底层实现，这个属性的值可以是表8-3列出的常量的其中一个。

![image](https://img2018.cnblogs.com/blog/1139419/201810/1139419-20181015114828893-896116069.png)
每种类型的对象都至少使用了两种不同的编码，每种类型的对象可以使用的编码如下

![image](https://img2018.cnblogs.com/blog/1139419/201810/1139419-20181015114841828-1523644461.png)

 通过encoding属性来设定对象所用的编码，而不是为特定类型的对象对象关联一种固定的编码，极大地提升了redis的灵活性和效率，因为redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。
 
  因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被赵茹到缓存中。

2 随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、更适合保存大量元素的双端链表。

# 五种对象
## 字符串对象
### 字符串对象的编码可以使int，raw或者embstr。
 ### 编码转换    
 ==如果一个字符串对象保存的是整数值==，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void *转换成long），==并将字符串对象的编码设置为int==
 

   ==如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节==，那么字符串对象将使用一个简单动态字符串（sds）来保存这个字符串值，==并将对象的编码设置为raw==。

   如果字符串对象保存的是一个字符串值，并且这个字符串值的长度==小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值==。
       
![image](https://img2018.cnblogs.com/blog/1139419/201810/1139419-20181015114914146-1160348561.png)

 embstr编码的字符串对象在执行命令时，产生的效果和raw编码的字符串对象执行命令时产生的效果是相同的，但使用embstr编码的字符串对象来保存短字符串值有以下好处：

1 embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降为一次。

2 释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。

3 因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。
## 列表对象
   列表对象的编码可以使ziplist或者linkedlist。
       
### ziplist编码的列表对象使用压缩列表作为底层实现
### linkedlist编码的列表对象使用双端链表作为底层实现,
       
   ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。下图就是ziplist编码的列表对象，红框内为存储的数据。
         
  ![image](https://img2018.cnblogs.com/blog/1139419/201810/1139419-20181015115031392-1641026435.png)
  
  linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素，如下图
  ![image](https://img2018.cnblogs.com/blog/1139419/201810/1139419-20181015115040574-801142087.png)
  
### 编码转换

当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：
    

1 列表对象保存的所有字符串元素的长度都小于64字节

2 列表对象保存的元素数量小于512个；

（以上两个条件的上限值可以修改）
当不满足的时候会自动转化为linkedlist

  ![image](https://img2018.cnblogs.com/blog/1139419/201810/1139419-20181015115052238-1976167267.png)

## 哈希对象
       ==哈希对象的编码可以是ziplist或者hashtable==。
       
### ziplist编码的哈希对象使用压缩列表作为底部实现

每当有新的键值对要加入到哈希对象时，程序会先保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：

1 保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后

2 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。

![image](https://img2018.cnblogs.com/blog/1139419/201810/1139419-20181015115134113-515955592.png)

![image](https://img2018.cnblogs.com/blog/1139419/201810/1139419-20181015115138517-1077764842.png)

### hashtable编码的哈希对象使用字典作为底层实现，

hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存
上例中，对应的hashtable编码的哈希对象如下图

![image](https://img2018.cnblogs.com/blog/1139419/201810/1139419-20181015115203274-1758974974.png)
### 编码转化：
      当哈希对象可以同时满足一下两个条件时，哈希对象使用ziplist编码

1 哈希对象保存的所有键值对的键和值字符串长度都小于64字节。

2 哈希对象保存的键值对数量小于512个

不能满足这两个条件的哈希对象需要使用hashtable编码（这两个条件的上限值可以在redis配置中修改。、
## 集合对象
集合对象的编码可以是intset或者hashtable。
### intset编码的集合对象使用证书集合作为底层实
### hashtable编码的集合对象使用字典作为底层实现
![image](https://img2018.cnblogs.com/blog/1139419/201810/1139419-20181015115228553-872319556.png)
### 编码转换

       当集合对象可以同时满足一下两个条件时，对象使用intset编码：

1 集合对象保存的所有元素都是整数值

2 集合对象保存的元素数量不超过512个

不能满足这两个条件的集合对象使用hashtable编码。
## 有序集合对象
有序集合的编码可以是ziplist或者skiplist。
 
==ziplist编码的压缩列表对象使用压缩列表作为底层实现==，每个集合元素使用两个金爱在一起的压缩列表节点保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值。

==压缩列表内的集合元素按分值从小到大金星排序==，分值较小的元素被防止在靠近表头的方向，而分值较大的元素责备防止在靠近表尾的方向，如下图。

### 编码的转换

       党有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：

1 有序集合同时保持的元素数量小于128个

2 有序集合保存的所有元素成员的长度都小于64字节