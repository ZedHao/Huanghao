[TOC]
# InnoDB体系架构
Innodb有多个内存块，
![image](https://img-blog.csdn.net/20180612011119133)
![image](07266E65D3C044DF8119F138A2485B18)

## 内存
（1）内存根据分工以及存储文件的不同分为==缓冲池、重做日志缓冲、额外内存池：==

缓冲池：InnoDB引擎是基于磁盘存储的，磁盘io慢，若在缓冲池中，称该页被命中，直接读取缓冲池中的页。否则，读取磁盘上的页，由此提高了读取的速度。

数据库修改数据操作时，首先修改在缓冲池的页，然后再异步刷新到磁盘上，从而提高改数据的速度。缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。


重做日志缓冲：InnoDB首先将重做日志信息放到这个缓冲区，然后按照一定频率将其刷新到重做日志文件。默认1秒钟刷新一次，因此重做日志缓冲一般不需要很大，默认8M。

日志在下列3种情况下会刷新重做日志缓冲：
- （1）每秒将重做日志缓冲刷新到重做日志文件
- 
- （2）每个事务提交时会将重做日志缓冲刷新到重做日志文件
- 
- （3）当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。

额外的内存池：在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请。

## 后台线程
（2）后台线程根据功能不同分==为master Thread、IO Thread、Purge Thread、Page Cleaner== Thread:

Master Thread【每秒和每十秒】:==负责将缓冲池中的数据异步刷新到磁盘==，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO夜的回收等。

IO Thread:在InnoDB存储引擎中大量使用异步 IO处理IO请求以提高数据库的性能，IO Thread负责这些IO请求的回调处理。IO Thread 有4类，分别为write、read、insert buffer、log IO thread。


Purge Thread：由于回收不再需要的undo页。

Page Cleaner Thread:将缓冲池中脏页（即被修改过于磁盘中数据不一致的页）刷新到磁盘中。
# InnoDB的三大特性
## 插入缓冲【针对非聚集索引】
对于==非聚集索引的插入和更新操作==，Innodb存储引擎并不是直接插入到索引页中，而是的Insert Buffer。==然后再以一定的频率进行insertbuffer和辅助索引叶子节点的merge。着通常将多个随机插入合并到一个操作中。大大提高了非聚集索引插入的性能。==

条件：索引不是非聚集索引且不是unique
## 一致性非锁定读

## 两次写
当数据库正在从内存向磁盘写一个数据页时，数据库宕机，从而导致这个页只写了部分数据，这就是部分写失效，它会导致数据丢失。这时是无法通过重做日志恢复的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力。

![image](https://img-blog.csdn.net/20130612080041468)
两次写需要额外添加两个部分：
- 1）内存中的两次写缓冲（doublewrite buffer），大小为2MB
- 2）磁盘上共享表空间中连续的128页，大小也为2MB

其原理是这样的：
- 1）当刷新缓冲池脏页时，并不直接写到数据文件中，而是先拷贝至内存中的两次写缓冲区。
- 2）接着从两次写缓冲区分两次写入磁盘共享表空间中，每次写入1MB
- 3）待第2步完成后，再将两次写缓冲区写入数据文件

这样就可以解决上文提到的部分写失效的问题，因为在磁盘共享表空间中已有数据页副本拷贝，如果数据库在页写入数据文件的过程中宕机，在实例恢复时，可以从共享表空间中找到该页副本，将其拷贝覆盖原有的数据页，再应用重做日志即可。

## 自适应哈希索引 
nnodb 存储引擎会监控对表上各索引页的查询，如果观察到建立hash索引可以带来速度的提升。则建立hash索引，称之为自适应hash索引（AHI).